# 정수 X (1<=X<=30,000)
# X%5 == 0 이면 X//5
# X%3 == 0 이면 X//3
# X%2 == 0 이면 X//2
# X - 1


# 최소 연산 횟수를 구하기
# 숫자 i에서 1을 뺀 값에 연산 횟수에 1을 더해서 (연산을 한번 한거니까.)초기화
# i는 계산해야하는 숫자이고 //5, //3, //2중에 하나를 선택해서 계산을 해보고,
# 해당 숫자를 나눴을 떄 되는 숫자의 연산 횟수와 비교해서 최소값이 되는 계산 방법을 넣는다.

# 피보나치 같은 규칙성을 발견할수는 없지만 작은 문제가 큰문제를 해결하는데 도움이 된다.
# 만약에 x = 1 이면 연산 횟수는 0번이다.
# 만약에 x = 2 이면 연산 횟수는 1번이다. (-1을 하면 1이 된다. 1번)
# 만약에 x = 3 이면 연산 횟수는 1번이다. (-1을 하면 2가 되고 3으로 나누면 1이 된다.)
# 만약에 x = 4 이면 연산 횟수는 2번이다. (-1을 하면 2가 된다.)
# 만약에 x = 5 이면 연산 횟수는 1번이다. (-1을 하면 3이되고 5로 나누면 1이된다.)
# 만약에 x = 6 이면 연산 횟수는 2번이다. (-1을 하면 2가 된다.)
# 만약에 x = 7 이면 연산 횟수는 3번이다. (-1을 하면 3이 된다.)
# 만약에 x = 8 이면 연산 횟수는 3번이다. (-1을 하면 4가 되고, 2로 나누면 3가 된다.)
# 만약에 x = 9 이면 연산 횟수는 2번이다. (-1을 하면 4가 되고, 3으로 나누면 2번이 된다.)

def to_one(X):
    number = [0]*(X+1)
    for i in range(2, X+1):
        number[i] = number[i-1] + 1
        if i % 2 == 0:
            number[i] = min(number[i], number[i//2]+1)
        if i % 3 == 0:
            number[i] = min(number[i], number[i//3]+1)
        if i % 5 == 0:
            number[i] = min(number[i], number[i//5]+1)
    return number[X]


print(to_one(100))
